# Миграция приложений на KMM

## Общие положения

### Архитектура

Архитектура основана на принципах **Clean Architecture**, представляет собой следующие слои (сверху вниз):

1. Бизнес-логика;
2. Бизнес сценарии;
3. Пользовательские сценарии;
4. Логика интерфейсов, хранение пользовательских данных, работа с апи.

Пример:

1. У пользователя есть профиль, он содержит никнейм, имя, пол, дату рождения. Никнейм обязателен, выдается системой при первой авторизации;
2. Пользователь может запросить свой профиль `LoadPersonalProfileUseCase`;
3. Пользователь открыл экран личного профиля, запущен сценарий загрузки профиля:
    1. Состояние экрана изменилось на `Loading`;
    2. Запустился бизнес-сценарий `LoadPersonalProfileUseCase`;
    3. Бизнес-сценарий завершен:
        1. Успешно — состояние экрана изменилось на `LoadingSuccess(profile)`;
        2. С ошибкой — состояние экрана изменилось на `LoadingError(error)`.
4. Низкоуровневая реализация сценариев:  
    1.  Пользователь нажал на таб личного профиля;
    2. Отобразился лоадер;
    3. Отправлен запрос `GET /user/profile`;
    4. Запрос выполнен:
        1. В случае успеха лоадер сменился экраном профиля содержащим никнейм, имя, пол, дату рождения;
        2. В случае ошибки лоадер сменился экраном описывающим возникшую проблему и кнопку с предложением повторить запрос.

### Бизнес-логика

Бизнесом является любое занятие, необязательно коммерческое. Бизнес-логикой является набор сущностей и правил, которыми оперирует бизнес. Для того чтобы понять, что является бизнес-логикой в вашем приложении перенесите его мыслено в оффлайн мир: те части, что останутся общими с приложением и являются бизнес-логикой. Пример:

1. iOS приложение для продажи печенья:
    1. Пользователь запускает iOS приложение по продаже печенья;
    2. C PHP сервера из PostgreSQL базы загружена информация, что шоколадное печенье сегодня продается со скидкой 20%;
    3. Пользователь видит анимацию с радостным единорогом, предлагающим выгодно приобрести пару килограммов наивкуснейшего шоколадного печенья;
2. Лоток с печеньем на рынке: 
    1. Покупатель приходит на рынок, чтобы купить печенья;
    2. Продавщица говорит покупателю "Здрасте! У нас сегодня шоколадное печенье со скидкой, брать будете?"

**Итого:** бизнес логика — это то, что мы продаем печенье, печенье обладает характеристикой "вкус", сегодня на печенье со вкусом "шоколад" скидка 20%.

В случае толстых клиентов или сервера у нас будет одна бизнес-сущность `Cookie` и одно бизнес-правило `CookieDiscount`. В случае тонких клиентов у нас будет только сущность `Cookie`, политику будет применять сервер.

### Бизнес-сценарии

Бизнес-сценарии — это операции доступные над бизнес-сущностями и политиками. Беря предыдущий пример с печеньем, мы можем иметь следующие сценарии: **"получить информацию о печенье"**, **"купить печенье"**, **"применить политику 'скидка на печенье'"**. Реализация бизнес-сценария представляет собой инкапсуляцию одного из методов репозитория, о них ниже. Технически является паттерном **"команда"**.

### Репозитории

Репозиторий — это абстракция над данными в виде коллекции. В конкретно нашем случае — это абстракция над бизнес-сущностями. Является суперстабильным интерфейсом со следующей сигнатурой:

```
`EntityRepository {
    create(createSpecification): Entity
    update(updateSpecification): Entity
    delete(deleteSpecification): Void
    find(searchQuery): List<Entity>
}
`
```

Спецификации **create**, **update**, **delete** и **searchQuery** являются маркерными интерфейсами, т.к. может возникнуть необходимость пробрасывать некую низкоуровневую логику, например параметры пагинации. Реализация представляет собой обращение к бизнес-сущностям через http-api, dao, драйвер БД и т.д. Пример:

Есть сущность `Cookie`. Есть бизнес-сценарии: **"выставить на продажу новое печенье"**, **"выставить скидку на шоколадное печенье"**, **"получить список доступных к продаже печений"**, **"снять печенье с продажи"**

```
`CookieRepository {

    create(createSpecification): CookieEntity {
        httpResponse = httpClient.execute("api.cookie.com", "POST", "/add_new", RequestBody(createSpecification.cookieTaste))
        if (httpResponse.success) {
            return httpResponse.body.mapToEntity() // http-сущность не является бизнес-сущностью, даже если она совпадает на 100%. необходимо всегда маппить в бизнес-сущность.
        }
    }

    update(updateSpecification): CookieEntity {
        // и т.д.
    }

    delete(deleteSpecification): Void {
        // и т.д.
    }

    find(searchQuery): List<CookieEntity> {
        // и т.д.
    }
}
`
```

Мотивация использования данного паттерна состоит в том, что с его помощью действительно легко можно менять реализации в отличии от того же DAO.

### Пользовательские сценарии

Реализованы с помощью паттерна `Unidirectional Data Flow` (далее `UDF`). Суть паттерна в том, что данные движутся всегда в одном и том же направлении, через одни и те же точки. Мотивация использования данного паттерна состоит в следующих пунктах:

1. Позволяет избегать наложения состояний — например когда поверх загруженных данных отображается лоадер. В случае если все же такая ошибка возникнет — на 100% известно, где находится баг и как его исправить (спойлер: очень просто);
2. Дает четкое разделение на пользовательские сценарии. Презентеры, через пару месяцев превращающиеся в **god-objects**, - это не про нас;
3. Позволяет очень быстро находить источники багов, исправлять их без боязни сломать что-то еще.

Технически выглядит как цепочка компонентов:

`Action -> SideEffect -> SideAction -> Reducer -> NewState`

Пример:

1. На нижнем уровне (пользовательском интерфейсе, например) произошел некий `Action`, допустим пользователь нажал на таб личного профиля - `Action.OpenPersonalProfile`;
2. Вызвался пользовательский сценарий (`SideEffect`), связанный с экшеном `OpenPersonalProfile`;
3. Сценарий может породить 0 или более `SideActions`, которые будут отправлены в `Reducer`;
4. `SideAction` передается в `Reducer`. `Reducer` является чистой функцией, т.е. функцией при одних и тех же входных параметрах возвращающей один и тот же результат и не изменяющей состояний каких либо объектов и систем. Конкретно Reducer принимает текущее состояние и `SideAction` и возвращает новое состояние. В нашем случае будет что-то типа:

```
`reducer(currentState, sideAction): ViewState {
    when (sideAction) {
        SideAction.LoadSuccess -> {
            return currentState.copy(loadingVisible = false, dataVisible = true, errorVisible = false, data = sideAction.data)
        }
        // другие экшены
    }
}
`
```

1. Новое состояние будет отправлено на нижний уровень, интерфейс должен быть приведен в вид соответствующий этому состоянию;
2. Возможны сценарии не вызывающие изменений состояний, такие как сценарии переходов между экранами, открытие диалогов, отображение всплывающих ошибок и т.д. В таком случае `SideEffect` через `EventDispatcher` отправляет соответствующее событие на нижний уровень.

### Нижний уровень

Тут в основном хочется указать на типичные ошибки:

### Пользовательские интерфейсы (в совокупности с UDF)

1. Толстые вьюхи:

```
`View {
    onProfileClick() {
        if (isPersonal()) {
            router.openPersonalProfile()
        } else {
            router.openUserProfile()
        }
    }
}
`
```

Логика начинает ветвиться и размазываться по слоям, становится сложней найти причину ошибки. В случае возникновения значимого события нужно отправлять его сразу в `Store`:

```
View {
    onProfileClick() {
        store.process(Action.ProfileClick)
    }
}
```

1. Толстые вьюхи, тонкие состояния:

```
`ViewState {
    data: List<Cookie>
    loading: Boolean
)

View {
    render(newState) {
        if (newState.data != null) {
            viewCookieList.set(newState.data)
            viewCookieList.show()
        } else {
            viewCookieList.hide()
            viewError.show()
        }
        if (newState.loading) {
            viewLoading.show()
        } else {
            viewLoading.hide()
        }
    }
}
`
```

Логика начинает ветвиться и размазываться по слоям, становится сложней найти причину ошибки. Состояние становится неоднозначно интерпретируемым, понятно только тому кто это первый раз написал. Правильная реализация `UDF` подразумевает однозначно трактуемые состояния:

```
ViewState {
    cookies: List<Cookie>
    loadingVisible: Boolean
    cookiesListVisible: Boolean
    errorVisible: Boolean
}
```

1. Отправка событий через состояние:

```
`ViewState {
    data: List<Cookie>
    showError: Boolean
}

View {
    render(newState) {
        if (newState.showError) {
            ErrorToast.show()
        }
    }
}
`
```

Последнее состояние должно отрисовываться при пересоздании экрана. Если в состояние добавить событие, то оно тоже будет каждый раз вызываться при пересоздании экрана.
Корректным решением данной проблемы будет использование `EventDispatcher`:


```
View {
    onEvent(newEvent) {
        when (newEvent) {
            is ShowError → showError()
        }
    }
}
```

### Реализации репозиториев

Неправильным решением будет добавлять в реализацию вещи отличающиеся от непосредственной работы с основным источником данных. Например: кэширование, фоновая загрузка. Должны быть реализованы на уровне пользовательских сценариев в виде отдельных компонентов.

## Миграция

Используя вышеописанные подходы можно реализовать кроссплатформенно слои бизнес-логики, бизнес-сценариев, пользовательских сценариев и реализаций репозиториев.

### Этапы внедрения

1. Библиотека бизнес-логики (т.к. у нас тонкие клиенты, будет содержать только бизнес-сущности);
2. Библиотека бизнес-сценариев (с нативной реализацией);
    1. Инкапсуляция текущего способа работы с бизнес-сущностями внутрь интерфейсов `usecase.repository`;
    2. Разделение на `usecases`.

1. Библиотека репозиториев (переход на кроссплатформенную реализацию бизнес-сценариев);
2. Библиотека UDF;
3. Библиотека пользовательских сценариев.

Первый пункт является основополагающим и в то же время самым простым. По сути внедрение данной библиотеки подразумевает лишь замену импортов.

Библиотека из второго пункта разделяет работу с сущностями на отдельные сценарии. Можно внедрять постепенно, по мере изменения/добавления фичей. На данном этапе рекомендуется начать использовать DI (если не используется).

Третий пункт - в случае следования рекомендации из предыдущего пункта внедрение библиотеки будет быстрым и безболезненным — так же как и в первом нужно будет лишь заменить импорты.

На четвертом этапе необходимо отрефакторить Controllers/Presenters: разбить на `SideEffects`, описать `ViewState`, определить наборы экшенов, вынести избыточную логику из вьюх. Может внедряться постепенно, по мере изменения/внедрения фичей.

Пятый пункт подразумевает замену нативных реализаций сценариев на их кроссплатформенные реализации.

В случае острой необходимости любой из компонентов может быть реализован нативно.

